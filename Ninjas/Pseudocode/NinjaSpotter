class NinjaSpotter:

	#Hash map should be used for keeping object lookup performance strong
	knownObjectsToOpponents <- empty hash map of objects to empty hash sets

	#adds x to the known objects map
	def CREATE(x):
		if x is not a key in the knownObjectsToOpponents map:
			insert key x and value empty hash set into knownObjectsToOpponents
		endif


	#add x and y as opponents
	#assumes x and y are in the map already
	def Oppose(x,y):
		if Opponents(x,y) yields that x and y are not opponents:
			report a logic error and halt execution
		endif

		x hash set <- hash set in knownObjectsToOpponents from key x
		y hash set <- hash set in knownObjectsToOpponents from key y
		
		x hash set <- x hash set UNION y
		y hash set <- y hash set UNION x

	
	#return whether x and y are on the same side, diff sides, or cannot be established
	#Has a time complexity of O(V+E)
	def Opponents(x,y):
		pathToY <- BreadthFirstSearch(x,y) which yields the objects on a shortest path to y from x including y; returns an empty set if there is no path

		if pathToY is the empty set:
			return that this property cannot be established

		else if the number of objects in the pathToY is odd:
			return that x and y are opponents
		endif

		#covers if the path length is even
		return that x and y are not opponents
		

	#Correctness for odd/even length of shortest path indicating opponent status
	
	#We know that the map of known objects stores opponents
	#Base case: x and y are directly opponents; the path from x to y is {y}; object count is odd, thus x and y are opponents
	
	#P(n) -> P(n+1):
	#Assume there is a shortest path x to y through x to u and u to y such that the even/odd scheme works for u to y and x directly connects to u 	(x-u-...-y)
	#path size increases by 1, toggling the object count between even and odd; since u~y is the shortest path, its length is deterministic
		
	#Assume u is opponents with y; Due to 1st assumptio, u~y has an odd number of objects
		#Since x is opponents with u, then x should NOT be opponents with y. 
		#Since the even / odd scheme works for u~y, the object count toggles from odd to even. Therefore x and y are NOT opponents.
		#QED P(n+1)

	#Assume u is NOT an opponent with y; Due to 1st assumption, u~y has an even number of objects
		#Since x is opponents with u, then x should be opponents with y. 
		#Since the even / odd scheme works for u~y, the object count toggles from even to odd. Therefore x and y are opponents.
		#QED P(n+1)


	#Correctness for BreadthFirstSearch yielding the shortest path from x to y

	#Assume	it does not and there exists a shorter path x-...-y; each edge has a weight of 1
	#A path can be taken from x to y that yields a shorter distance to y
	#Contradiction: Breadth first searches have the property that during exploration, distance from the root strictly increase. 
		If a shorter path to y exists, then either the distance would have to decrease, violating this property or the path would have been discovered earlier
	#Thus, Breadth First Search yields the shortest path
